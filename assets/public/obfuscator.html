<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="robots" content="noindex, nofollow" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Chat Analytics - Export obfuscator</title>
        <link rel="canonical" href="https://chatanalytics.app/obfuscator.html" />
        <link rel="icon" type="image/png" href="https://chatanalytics.app/favicon.png" />
    </head>
    <body>
        <h3>Export obfuscator</h3>
        <p>
            If you're needing to share an export as a sample for testing or debugging, you will want to obfuscate it to
            protect any personal information such as message contents, IDs, author information and URLs. This tool will
            do that for you.
        </p>
        <form>
            <fieldset>
                <legend>Platform</legend>
                <input type="radio" id="discord" name="platform" value="discord" checked />
                <label for="discord">Discord</label>

                <input type="radio" id="telegram" name="platform" value="telegram" />
                <label for="telegram">Telegram</label>
            </fieldset>

            <br />

            <fieldset>
                <legend>Export files</legend>
                <input type="file" id="files" name="files" accept=".json" multiple />
            </fieldset>

            <p>What will be obfuscated:</p>

            <ul>
                <li>asd</li>
                <li>asd</li>
                <li>asd</li>

                <li>
                    <input type="checkbox" id="obMessages" name="obMessages" checked disabled />
                    <label for="obMessages">Obfuscate message content</label>
                </li>
                <li>
                    <input type="checkbox" id="obNames" name="obNames" checked />
                    <label for="obNames">Obfuscate names (of channels, authors, guilds...)</label>
                </li>
                <li>
                    <input type="checkbox" id="obIDs" name="obIDs" checked />
                    <label for="obIDs"
                        >Obfuscate IDs (of messages, channels, authors, guilds...). Keep in mind these can sometimes be
                        reverse-engineered to find more information</label
                    >
                </li>
                <li>
                    <input type="checkbox" id="obMedia" name="obMedia" checked />
                    <label for="obMedia">Obfuscate media (profile pictures, attachments...)</label>
                </li>
                <li>
                    <label for="obTimestamps">Obfuscate timestamps by...</label>
                    <select id="obTimestamps" name="obTimestamps">
                        <option value="dont">Don't obfuscate timestamps</option>
                        <option value="unix0">Set all timestamps to unix 0</option>
                        <option value="currentTimestamp">Set all timestamps to current timestamp</option>
                        <option value="roundSecs">Round timestamps down to second</option>
                        <option value="roundMins">Round timestamps down to minute</option>
                        <option value="roundHrs">Round timestamps down to hour</option>
                        <option value="roundDays">Round timestamps down to day</option>
                    </select>
                </li>
            </ul>
            <input type="button" id="obfuscate" value="Obfuscate" disabled />

            <br />
            <br />

            <fieldset>
                <legend>Output</legend>
                <div id="output">Nothing</div>
            </fieldset>
        </form>
        <script type="module">
            import { faker } from "https://cdn.skypack.dev/@faker-js/faker";

            class ObjectGroup {
                objects = new Map();
                nextId = 1;

                constructor(generator) {
                    this.generator = generator;
                }

                get(object) {
                    const str = JSON.stringify(object);
                    if (!this.objects.has(str)) {
                        this.objects.set(str, this.generator(object, this.nextId++));
                    }
                    return this.objects.get(str);
                }
            }

            class Obfuscator {
                obfuscate(content) {
                    throw new Error("Not implemented");
                }

                // Obfuscate timestamp, result must be after `after`, if provided
                obfuscateTimestamp(timestamp, after) {
                    if (after) {
                        // ...
                    }
                    // TODO: use...
                    return -1;
                }

                obfuscateMessageContent(content) {
                    const wordsInContent = content.split(" ");
                    return faker.lorem.sentence(wordsInContent.length);
                }
            }

            class DiscordObfuscator extends Obfuscator {
                constructor() {
                    super();

                    // note: ids must be strings
                    this.guilds = new ObjectGroup((guild, id) => ({
                        id: `${id}`,
                        name: faker.internet.domainWord(),
                        iconUrl: "https://cdn.discordapp.com/embed/avatars/0.png", // default
                    }));
                    this.channels = new ObjectGroup((channel, id) => ({
                        id: `${id}`,
                        type: channel.type,
                        name: faker.internet.domainWord(),
                    }));
                    this.authors = new ObjectGroup((author, id) => ({
                        id: `${id}`,
                        name: faker.internet.userName(),
                        discriminator: author.discriminator, // not identifiable
                        nickname: faker.internet.displayName(),
                        color: faker.color.rgb(),
                        isBot: author.isBot,
                        avatarUrl: "https://cdn.discordapp.com/embed/avatars/0.png", // default
                    }));
                    this.messages = new ObjectGroup((message, id) => {
                        // const ts = this.obfuscateTimestamp(new Date(message.timestamp));

                        return {
                            id: `${id}`,
                            type: message.type,
                            timestamp: message.timestamp,
                            timestampEdited: message.timestampEdited,
                            callEndedTimestamp: message.callEndedTimestamp,
                            isPinned: message.isPinned,
                            content: this.obfuscateMessageContent(message.content),
                            author: this.authors.get(message.author),
                            // TODO:
                            attachments: [],
                            embeds: [],
                            reactions: [],
                            mentions: [],
                        };
                    });
                }

                obfuscate(content) {
                    const data = JSON.parse(content);
                    const file = {
                        guild: this.guilds.get(data.guild),
                        channel: this.channels.get(data.channel),
                        dateRange: {
                            after: null,
                            before: null,
                        },
                        messages: data.messages.map((message) => this.messages.get(message)),
                        messageCount: data.messageCount,
                    };
                    return JSON.stringify(file, null, 2);
                }
            }

            class TelegramObfuscator extends Obfuscator {
                obfuscate(content) {
                    return {
                        a: "b",
                    };
                }
            }

            ////////////////////////////////////////
            ////////////////////////////////////////
            ////////////////////////////////////////

            const filesElement = document.querySelector('input[name="files"]'),
                obfuscateButton = document.getElementById("obfuscate"),
                outputElement = document.getElementById("output");

            const getFiles = () => filesElement.files;

            filesElement.onchange = () => {
                obfuscateButton.disabled = getFiles().length === 0;
            };

            obfuscateButton.onclick = async () => {
                outputElement.textContent = "Working...";

                try {
                    const ObfuscatorClass = {
                        discord: DiscordObfuscator,
                        telegram: TelegramObfuscator,
                    }[document.querySelector('input[name="platform"]:checked').value];
                    const obfuscator = new ObfuscatorClass();

                    const ul = document.createElement("ul");

                    for (const file of getFiles()) {
                        const name = (await digestText(file.name)) + ".json";
                        const text = await file.text();
                        const output = obfuscator.obfuscate(text);

                        const blob = new Blob([output], { type: "application/json" });
                        const url = URL.createObjectURL(blob);

                        const li = document.createElement("li");
                        const a = document.createElement("a");
                        a.href = url;
                        a.download = name;
                        a.textContent = name;
                        li.appendChild(a);
                        li.appendChild(document.createTextNode(" (" + file.name + ")"));
                        ul.appendChild(li);
                    }

                    outputElement.textContent = "";
                    outputElement.appendChild(ul);
                } catch (e) {
                    outputElement.textContent = "Error: " + e.message;
                    throw e;
                }
            };

            // taken from https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
            async function digestText(message) {
                const msgUint8 = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array
                const hashBuffer = await crypto.subtle.digest("SHA-1", msgUint8); // hash the message
                const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array
                const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join(""); // convert bytes to hex string
                return hashHex;
            }
        </script>

        <script>
            const fileUpload = document.getElementById("file"),
                detectedPlatform = document.getElementById("detectedPlatform"),
                obfuscateButton = document.getElementById("obfuscateButton"),
                downloadButton = document.getElementById("downloadButton"),
                previewElm = document.getElementById("preview"),
                PLATFORM_KEYS = {
                    Discord: ["guild", "channel", "dateRange", "messages", "messageCount"],
                    Messenger: [
                        "participants",
                        "messages",
                        "title",
                        "is_still_participant",
                        "thread_type",
                        "thread_path",
                        "magic_words",
                    ],
                    Telegram: ["name", "type", "id", "messages"],
                },
                MESSAGE_CONTENT_REDACTION = "Lorem ipsum";

            const WHATSAPP_LINE_START_REGEX = /^(\d\d)\/(\d\d)\/(\d{4}), (\d\d):(\d\d) - (.+)$/;
            const WHATSAPP_MESSAGE_CONTENT_REGEX = /^(.+?): (.+)/;
            const WHATSAPP_WHITELISTED_CONTENTS = ["<Media omitted>", "This message was deleted"];

            // While obfuscated usernames are consistent, obfuscated user IDs and other user information will be the same
            const JSON_PLATFORMS_PATHS = {
                Discord: {
                    Messages: [
                        {
                            path: "messages$content",
                            obfuscation: MESSAGE_CONTENT_REDACTION,
                        },
                        {
                            // Could be obfuscated individually to maintain null values
                            path: "messages$embeds$",
                            obfuscation: {
                                title: "Example embed", // Can also be null
                                url: null,
                                timestamp: null,
                                description: null,
                                color: null,
                                author: null,
                                thumbnail: null,
                                images: [],
                                fields: [],
                            },
                        },
                    ],
                    Names: [
                        {
                            path: "guild.name",
                            obfuscation: "Example guild",
                            whitelist: ["Direct Messages"],
                        },
                        {
                            path: "channel.category",
                            obfuscation: "Example category",
                            whitelist: ["Private"],
                        },
                        {
                            path: "channel.name",
                            obfuscation: "Example channel",
                        },
                        {
                            path: "channel.topic",
                            obfuscation: "Topic for example channel",
                            whitelist: [null],
                        },
                        {
                            path: "messages$author.name",
                            is_user_name: true,
                        },
                        {
                            path: "messages$author.nickname",
                            is_user_name: true,
                        },
                        {
                            path: "messages$mentions.name",
                            is_user_name: true,
                        },
                        {
                            path: "messages$mentions.nickname",
                            is_user_name: true,
                        },
                    ],
                    IDs: [
                        {
                            path: "guild.id",
                            obfuscation: 123456789123456789,
                            whitelist: [0],
                        },
                        {
                            path: "channel.id",
                            obfuscation: 123456789123456789,
                            whitelist: [0],
                        },
                        {
                            path: "channel.category.id",
                            obfuscation: 123456789123456789,
                            whitelist: [0],
                        },
                        {
                            path: "messages$id",
                            obfuscation: 123456789123456789,
                        },
                        {
                            path: "messages$author.id",
                            obfuscation: 123456789123456789,
                        },
                        {
                            path: "messages$author.discriminator", // While not unique to individual users, people who know the user could make an educated guess
                            obfuscation: 1234,
                        },
                        {
                            path: "messages$attachments.id",
                            obfuscation: 123456789123456789,
                        },
                        {
                            path: "messages$mentions.id",
                            obfuscation: 123456789123456789,
                        },
                        {
                            path: "messages$mentions.discriminator", // While not unique to individual users, people who know the user could make an educated guess
                            obfuscation: 1234,
                        },
                        {
                            path: "messages$reference.messageId",
                            obfuscation: 123456789123456789,
                        },
                        {
                            path: "messages$reference.channelId",
                            obfuscation: 123456789123456789,
                        },
                        {
                            path: "messages$reference.guildId",
                            obfuscation: 123456789123456789,
                        },
                        // Could also include stickers and reactions, which can be specific to guilds, but most aren't and each should be differentiated in some way
                    ],
                    Media: [
                        {
                            path: "guild.icon_url",
                            obfuscation: "https://cdn.discordapp.com/embed/avatars/0.png",
                        },
                        {
                            path: "messages$author.avatarUrl",
                            obfuscation: "https://cdn.discordapp.com/embed/avatars/0.png",
                        },
                        {
                            path: "messages$attachments.url",
                            obfuscation:
                                "https://cdn.discordapp.com/attachments/123456789123456789/123456789123456789/example.png",
                        },
                        {
                            path: "messages$attachments.filename",
                            obfuscation: "example.png",
                        },
                        // Could obfuscate messages$attachments.fileSizeBytes but not sure if this is necessary
                    ],
                    Timestamps: [
                        {
                            path: "dateRange.after",
                            whitelist: [null],
                            toDate: (value) => new Date(value),
                        },
                        {
                            path: "dateRange.before",
                            whitelist: [null],
                            toDate: (value) => new Date(value),
                        },
                        {
                            path: "messages$timestamp",
                            toDate: (value) => new Date(value),
                        },
                        {
                            path: "messages$timestampEdited",
                            whitelist: [null],
                            toDate: (value) => new Date(value),
                        },
                        {
                            path: "messages$callEndedTimestamp",
                            whitelist: [null],
                            toDate: (value) => new Date(value),
                        },
                    ],
                },
                Messenger: {
                    // Supposedly there is a messages$ip property,
                    // but I can't find it in any of my own exports and not sure what it was for
                    Messages: [
                        {
                            path: "messages$content",
                            obfuscation: MESSAGE_CONTENT_REDACTION,
                        },
                    ],
                    Names: [
                        {
                            path: "participants$name",
                            is_user_name: true,
                        },
                        {
                            path: "title",
                            obfuscation: "Example group chat title", // Doesn't take into account DMs
                        },
                        {
                            path: "thread_path",
                            obfuscation: "index/example_aaaaaaaaaa",
                        },
                        {
                            path: "messages$sender_name",
                            is_user_name: true,
                        },
                    ],
                    IDs: [
                        {
                            // I can't actually find this property in my own exports, both old and new,
                            // but it appears in /tests/samples/messenger/2A_7M.json, so I've included it
                            path: "messages$sender_id_INTERNAL",
                            obfuscation: 0,
                        },
                        // Some IDs are also included in media URIs
                    ],
                    Media: [
                        // Supposedly there are messages$files$media_path_INTERNAL and messages$files$type_INTERNAL properties,
                        // but I can't find either of these in any of my own exports and not sure what they're for
                        {
                            path: "messages$files$uri",
                            obfuscation: "messages/inbox/example_1234567812345678/files/example.txt",
                        },
                        {
                            path: "messages$photos$uri",
                            obfuscation:
                                "messages/inbox/example_1234567812345678/photos/12345678_123456781234567_1234567890123456789_n_123456781234567.jpg",
                        },
                        {
                            path: "messages$videos$uri",
                            obfuscation:
                                "messages/inbox/example_1234567812345678/videos/12345678_123456781234567_1234567890123456789_n_123456781234567.mp4",
                        },
                        {
                            path: "messages$gifs$uri",
                            obfuscation:
                                "messages/inbox/example_1234567812345678/gifs/12345678_123456781234567_1234567890123456789_n_123456781234567.gif",
                        },
                    ],
                    Timestamps: [
                        {
                            path: "messages$timestamp_ms",
                            toDate: (value) => new Date(value),
                        },
                        {
                            path: "messages$files$creation_timestamp",
                            toDate: (value) => new Date(value * 1000),
                        },
                        {
                            path: "messages$photos$creation_timestamp",
                            toDate: (value) => new Date(value * 1000),
                        },
                        {
                            path: "messages$videos$creation_timestamp",
                            toDate: (value) => new Date(value * 1000),
                        },
                    ],
                },
                Telegram: {
                    Messages: [
                        {
                            path: "messages$text",
                            obfuscation: [MESSAGE_CONTENT_REDACTION],
                        },
                        {
                            path: "messages$text_entities",
                            obfuscation: [MESSAGE_CONTENT_REDACTION],
                        },
                    ],
                    Names: [
                        {
                            path: "name",
                            obfuscation: "Example name",
                        },
                        {
                            path: "from",
                            is_user_name: true,
                        },
                    ],
                    IDs: [
                        {
                            path: "id",
                            obfuscation: 1111111111,
                        },
                        {
                            path: "messages$id",
                            obfuscation: 1234,
                        },
                        {
                            path: "messages$from_id",
                            obfuscation: 1111111111,
                        },
                    ],
                    Timestamps: [
                        {
                            path: "messages$date",
                            toDate: (value) => new Date(value),
                        },
                        {
                            path: "messages$date_unixtime",
                            toDate: (value) => new Date(value),
                        },
                    ],
                },
            };

            function readFileThen(then) {
                const reader = new FileReader();
                reader.onload = (e) => then(e.target.result);
                reader.readAsText(fileUpload.files[0]);
            }

            function sameMembers(arr1, arr2) {
                const set1 = new Set(arr1);
                const set2 = new Set(arr2);
                return arr1.every((item) => set2.has(item)) && arr2.every((item) => set1.has(item));
            }

            let platform;
            function setDetectedPlatform(platformName) {
                platform = platformName;
                detectedPlatform.textContent = "Detected platform " + platformName;
                obfuscateButton.disabled = false;
            }
            function failDetectingPlatform(reason) {
                platform = null;
                detectedPlatform.textContent = "Could not detect platform; " + reason;
                obfuscateButton.disabled = true;
            }
            fileUpload.onchange = (e) => {
                const ext = e.target.files[0].name.split(".").pop();
                if (ext === "txt") setDetectedPlatform("WhatsApp");
                else if (ext === "json") {
                    readFileThen((contents) => {
                        const keys = Object.keys(JSON.parse(contents));
                        for (const [platformName, expectedKeys] of Object.entries(PLATFORM_KEYS)) {
                            if (sameMembers(expectedKeys, keys)) {
                                setDetectedPlatform(platformName);
                                break;
                            }
                        }
                        if (!platform) failDetectingPlatform("JSON keys do not match any expected keys");
                    });
                } else failDetectingPlatform("file should be .txt or .json");
            };

            function shouldObfuscate(feature) {
                return document.getElementById("ob" + feature).checked;
            }

            // Replaces all values in obj (based on paths) with the return value of func given the current value
            // paths is a list of strings, each listing period-delimited properties to traverse in obj,
            // where each item in the property value is iterated through before continuing (until last path)
            function traverseObject(obj, func, paths) {
                const props = paths[0].split(".");
                const lastIndex = props.length - 1;
                props.reduce((curr, prop, i) => {
                    if (curr === undefined) return undefined;
                    if (i === lastIndex) {
                        if (paths.length === 1) {
                            curr[prop] = func(curr[prop]);
                        } else {
                            paths.shift();
                            for (const item of curr[prop]) {
                                traverseObject(item, func, paths);
                            }
                        }
                    }
                    return curr[prop];
                }, obj);
            }

            class Obfuscator {
                authors = [];

                constructor() {
                    this.platform = platform;
                    this.obNames = shouldObfuscate("Names");
                    this.timestampObLevel = document.getElementById("obTimestamps").value;
                }

                obfuscate(fileContents) {
                    return this.platform === "WhatsApp"
                        ? this.obfuscateWhatsApp(fileContents)
                        : this.obfuscateJSONFile(fileContents);
                }

                // Would be better to use whatsapp-chat-parser, but the obfuscator is intended to be stand-alone
                // In case we switch to whatsapp-chat-parser, I've chosen to not make this function to extensive
                // But I've ensured to leave plenty room for future improvement
                obfuscateWhatsApp(fileContents) {
                    return fileContents
                        .split("\n")
                        .map((line) => {
                            const lineMatch = WHATSAPP_LINE_START_REGEX.exec(line);
                            if (!lineMatch) return null;
                            const d = lineMatch.slice(1, 6).map(Number);
                            const newTimestamp = this.obfuscateTimestamp(
                                new Date(d[2], d[1] - 1, d[0], d[3], d[4])
                            ).toLocaleString("en-GB", {
                                day: "2-digit",
                                month: "2-digit",
                                year: "numeric",
                                hour: "2-digit",
                                minute: "2-digit",
                            });
                            const messageMatch = WHATSAPP_MESSAGE_CONTENT_REGEX.exec(lineMatch[6]);
                            if (!messageMatch) return `${newTimestamp} - ${lineMatch[6]}`;
                            const newAuthor = this.obfuscateUserName(messageMatch[1]);
                            const newContent = WHATSAPP_WHITELISTED_CONTENTS.includes(messageMatch[2])
                                ? messageMatch[2]
                                : MESSAGE_CONTENT_REDACTION;
                            return `${newTimestamp} - ${newAuthor}: ${newContent}`;
                        })
                        .filter((line) => line)
                        .join("\n");
                }

                obfuscateJSONFile(fileContents) {
                    let data = JSON.parse(fileContents); // Modified inside obfuscateOccurrence / setValueAtLocation
                    for (const [feature, occurrences] of Object.entries(JSON_PLATFORMS_PATHS[this.platform])) {
                        if (shouldObfuscate(feature)) {
                            for (const occurrence of occurrences) {
                                traverseObject(
                                    data,
                                    (currentValue) => {
                                        if ("whitelist" in occurrence && occurrence.whitelist.includes(currentValue))
                                            return currentValue;
                                        if ("is_user_name" in occurrence && occurrence.is_user_name)
                                            return this.obfuscateUserName(currentValue);
                                        if ("toDate" in occurrence)
                                            this.obfuscateTimestamp(occurrence.toDate(currentValue));
                                        return occurrence.obfuscation;
                                    },
                                    occurrence.path.split("$")
                                );
                            }
                        }
                    }
                    return JSON.stringify(data);
                }

                obfuscateTimestamp(timestamp) {
                    switch (this.timestampObLevel) {
                        case "unix0":
                            return new Date(0);
                        case "currentTimestamp":
                            return new Date();
                        case "roundDays":
                            timestamp.setHours(0);
                        case "roundHrs":
                            timestamp.setMinutes(0);
                        case "roundMins":
                            timestamp.setSeconds(0);
                        case "roundSecs":
                            timestamp.setMilliseconds(0);
                    }
                    return timestamp;
                }

                obfuscateUserName(username) {
                    if (this.obNames) {
                        if (!this.authors.includes(username)) {
                            this.authors.push(username);
                        }
                        return "User " + (this.authors.indexOf(username) + 1);
                    }
                    return username;
                }
            }

            let result;
            obfuscateButton.onclick = () => {
                if (!platform) return;
                const obfuscator = new Obfuscator();
                readFileThen((contents) => {
                    result = obfuscator.obfuscate(contents);
                    previewElm.innerHTML = result.slice(0, 10000).split("\n").slice(0, 50).join("<br>"); // These values are very arbitrary
                    downloadButton.disabled = false;
                });
            };
            downloadButton.onclick = () => {
                const a = document.createElement("a");
                a.href = "data:text/plain;charset=utf-8," + encodeURIComponent(result);
                a.download = fileUpload.files[0].name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            };
        </script>
    </body>
</html>
